#  Использую алгоритм быстрой сортировки
def quicksort(s):
    if len(s) <= 1:  # условие выхода из рекурсии: если длина списка меньше или равна 1,
        return s     # то этот список возвращается, так как такой список уже отсортирован
    elem = s[0]  # назначается ведущий элемент, в этом случае первый в списке
    levaya = list(filter(lambda x: x < elem, s))   # список делится на левую часть, где все элементы меньше ведущего
    center = [i for i in s if i == elem]           # в центральной части элементы, равные ведущему
    pravaya = list(filter(lambda x: x > elem, s))  # правая часть, где все элементы больше ведущего

    # рекурсивно возвращается левая и правая часть, так как они нуждаются в сортировке
    # центральная часть возвращается без функции, так как центр состоит только из ведущих элементов
    return quicksort(levaya) + center + quicksort(pravaya)

#  Использую итеративный вариант двоичного поиска
def binarySearch(spisok, val):
    left = 0  # Список делится на левую часть, поиск с первого элемента,
    right = len(spisok)-1  # и на правую часть, поиск с последнего элемента
    while right > left:  # Если условие НЕ выполняется, значит искомое число val находится за пределами границ списка
        middle = (right + left) // 2  # Определяем центр, так как индекс - это всегда целое число, то //2
        if spisok[middle] == val:  # Если центральный элемент и есть искомое число,
            return f"{middle-1} - это индекс числа, которое меньше {val}\n" \
                   f"{middle+1} - это индекс следующего числа, которое больше либо равно {val}"
        elif spisok[left] == val:  # Если левый элемент и есть искомое число
            if spisok[left] == spisok[0]:  # и при этом это первый/наименьший элемент,
                return f"{val} - наименьшее число в списке\n" \
                       f"{left+1} - это индекс следующего числа, которое больше либо равно {val}"
        elif spisok[right] == val:  # Если правый элемент и есть искомое число
            if spisok[right] == spisok[-1]:  # и при этом это последний/наибольший элемент,
                return f"{val} - наибольшее число в списке\n" \
                       f"{right-1} - это индекс числа, которое меньше {val}\n"
        elif spisok[middle] > val:  # условие, когда элемент не нашелся в списке
            if right == middle:  # пока границы не сузятся до одного элемента
                return f"{left} - это индекс числа, которое меньше {val}\n" \
                       f"{right} - это индекс следующего числа, которое больше либо равно {val}"
            right = middle  # сужение границы поиска
        else:  # условие, когда элемент не нашелся в списке
            if left == middle:  # пока границы не сузятся до одного элемента
                return f"{left} - это индекс числа, которое меньше {val}\n" \
                       f"{right} - это индекс следующего числа, которое больше либо равно {val}"
            left = middle  # сужение границы поиска


while True:  # Проверяются условия ввода последовательности чисел
    try:
        s = list(set(map(int, input("Введите последовательность чисел через пробел: ").split())))
        if len(s) <= 1:  # Если ничего не вводится или только пробел или только одно число
            print("Без нескольких разных чисел не получится, попробуйте ввести данные ещё раз.")
            continue
        else:
            break
    except ValueError:  # Если вводится символ, отличный от цифры и пробела
        print()
        print("Вы ошиблись при вводе. Можно вводить только числа и разделять их пробелом, попробуйте ещё раз.")
        print()
        continue

spisok = quicksort(s)  # Выполняется сортировка последовательности

while True:  # Проверяются условия ввода произвольного числа
    try:
        val = int(input('Введите произвольное число: '))
        if val < spisok[0] or val > spisok[-1]:  # Если число за пределами границ последовательности
            print(f"Число находится за пределами последовательности."
                  f" Попробуйте ввести число от {spisok[0]} до {spisok[-1]} включительно.")
            continue
        else:
            break
    except ValueError:  # Если вводится символ, отличный от цифр
        print()
        print("Вы ввели недопустимый символ. Число должно состоять только из цифр, попробуйте ещё раз.")
        print()
        continue


print("Последовательность отсортирована:", *spisok)
print(binarySearch(spisok, val))